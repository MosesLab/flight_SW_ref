%\documentclass[11pt]{article}
%\begin{document}
\section{Architecture Description}
\hrulefill
\\
The MOSES instrument needs to be able to respond to IO on several different interfaces. This is problematic for a sequential programming architecture, as input could be lost while the computer is executing another part of the program or output could be executed late while the software is waiting for something else. This issue is alleviated by using a threaded software architecture, which can execute separate subprograms concurrently. Linux provides excellent support for threaded programming, known as POSIX threads (pthreads). Pthreads allows the flight software to execute the Science Timeline, while still being available to respond to commands from the ground or write data to the hard-disk drive. \par 
The challenge with this threaded architecture is one of thread synchronization. Each thread operates independently, and steps must be taken to ensure that the program executes in the proper order and no memory is accessed simultaneously by two or more threads. In the MSFW thread synchronization is accomplished through so-called Locking Queues. These objects are implemented anywhere in the porgram where the producer-consumer problem is present, where one thread is producing data while the other is waiting to do operations on that data. Locking Queues are identical to a normal queue data structure, except that they take advantage of mutual-exclusion (mutex) locks to ``lock'' the queue until the accessing thread has completed its operation on the queue. The Locking Queue also uses a conditional variable to get the attention of the consumer waiting for input.
Another thread synchronization technique utilized in the MFSW is signals. Signals are objects provided by the Linux OS that allow separate threads or processes to get each others attention through a binary flag. In the MFSW, the SIGINT signal is used to instruct the main process to shut down the flight software. Another signal, SIGUSR1 is used as a backdoor to command exposures during FSW debugging. This allows rudimentary control over the FSW without the need for the EGSE software.
Finally, the last thread synchronization technique is known as a semaphore. Only one semaphore is used in the MFSW, and it is used to synchronize operations between the FPGA Server thread and the Science Timeline thread. A Locking Queue would have been used here, but as of this writing there seems to be a bug in the  \texttt{pthread\_cond\_timedwait()} function that prevents it from operating properly. \par 
The software is broken up into threads based off of input/output requirements. For the most part, each thread represents one IO interface that can only be controlled by the associated thread. The exception to this rule is the ROE CMD/HK interface, which is accessed by both the Science Timeline and the HLP Control threads. Upon program start, the first thread to be executed is the Main thread. Its purpose is to start all the other threads and wait for a signal to shut down the FSW. The most important thread in the software is the Science Timeline thread. This thread controls the timing of the experiment, while relying on other threads to communicate with the appropriate interfaces. Another important thread is the FPGA Server thread. This thread mediates communications between the FSW and the FPGA, and is directly responsible for capturing science data and for notifying the software of GPIO input. All of the other threads are usually responsible for separate IO interfaces and will be explained in-depth below.
